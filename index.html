<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Second-Synced Animated Clock</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            /* Changed to a gradient to demonstrate transparency */
            background-image: linear-gradient(to top, #a18cd1 0%, #fbc2eb 100%);
            color: #374151;
        }
        .clock-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
        }
        canvas {
            /* Removed background-color to make the canvas transparent */
            border-radius: 50%;
            /* The shadow now applies to the drawing, giving a floating effect */
            filter: drop-shadow(0 4px 6px rgba(0,0,0,0.1));
        }
    </style>
</head>
<body>
    <div class="clock-container">
        <canvas id="clockCanvas" width="300" height="300"></canvas>
    </div>

    <script>
        // --- Canvas and Clock Setup ---
        const canvas = document.getElementById('clockCanvas');
        const ctx = canvas.getContext('2d');
        const radius = canvas.height / 2;
        const center = radius;

        // --- Image Loading ---
        const bgImage = new Image();
        // The crossOrigin attribute must be set before the src attribute for security.
        bgImage.crossOrigin = "Anonymous";
        // Using a reliable, CORS-friendly image source to prevent loading errors.
        bgImage.src = 'https://picsum.photos/300/300'; 
        
        bgImage.onerror = () => {
            console.error("Failed to load image. Falling back to a placeholder.");
            // Fallback to a plain placeholder if the primary image fails
            const fallbackImage = new Image();
            fallbackImage.src = "https://placehold.co/300x300/e0e0e0/666666?text=Image+Error";
            fallbackImage.onload = () => {
                 ctx.drawImage(fallbackImage, 0, 0, canvas.width, canvas.height);
            }
        };

        /**
         * Draws the entire clock face, including background, markers, and hands.
         * This function is called on every animation frame.
         */
        function drawClock() {
            const now = new Date();
            const seconds = now.getSeconds();

            // --- 1. Clear and Prepare Canvas ---
            // This now clears to transparent instead of white.
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // The static white background circle has been removed.

            // --- 2. Draw Clipped Background Image ---
            ctx.save(); // Save the current state
            
            // Create a clipping path. The amount of image shown depends on the current second.
            ctx.beginPath();
            ctx.moveTo(center, center);
            
            // Each second, the starting angle of the visible part of the image increases.
            // This effectively "removes" a slice from the beginning each second.
            const startAngle = (seconds * (Math.PI * 2 / 60)) - (Math.PI / 2);
            const endAngle = (2 * Math.PI) - (Math.PI / 2); // The end of the circle
            
            ctx.arc(center, center, radius, startAngle, endAngle);
            ctx.closePath();
            ctx.clip(); // Apply the clipping path
            
            // Draw the image - it will only appear within the clipped area
            if (bgImage.complete && bgImage.naturalHeight !== 0) { // Check if the image is actually loaded
                ctx.drawImage(bgImage, 0, 0, canvas.width, canvas.height);
            }
            
            ctx.restore(); // Restore the state, removing the clip

            // --- 3. Draw Markers ---
            for (let i = 1; i <= 12; i++) {
                const angle = i * Math.PI / 6;
                const isProminent = i % 3 === 0;
                
                ctx.beginPath();
                ctx.lineWidth = isProminent ? 3 : 2;
                ctx.strokeStyle = isProminent ? '#93c5fd' : '#dbeafe'; // blue-300 : blue-100
                
                const x1 = center + (radius - (isProminent ? 15 : 10)) * Math.sin(angle);
                const y1 = center - (radius - (isProminent ? 15 : 10)) * Math.cos(angle);
                const x2 = center + (radius - 4) * Math.sin(angle);
                const y2 = center - (radius - 4) * Math.cos(angle);
                
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
            }

            // --- 4. Draw Hands ---
            const minutes = now.getMinutes();
            const hours = now.getHours();

            // Hour Hand
            let hourAngle = (hours % 12 + minutes / 60) * Math.PI / 6 - Math.PI / 2;
            drawHand(hourAngle, radius * 0.5, 8, '#1e3a8a'); // blue-900

            // Minute Hand
            let minuteAngle = (minutes + seconds / 60) * Math.PI / 30 - Math.PI / 2;
            drawHand(minuteAngle, radius * 0.75, 6, '#2563eb'); // blue-600

            // Second Hand
            let secondAngle = (seconds) * Math.PI / 30 - Math.PI / 2;
            drawHand(secondAngle, radius * 0.9, 2, '#60a5fa'); // blue-400
            
            // --- 5. Draw Center Dot ---
            ctx.beginPath();
            ctx.arc(center, center, 6, 0, 2 * Math.PI);
            ctx.fillStyle = '#1e3a8a'; // blue-900
            ctx.fill();
        }

        /**
         * Helper function to draw a single clock hand.
         */
        function drawHand(angle, length, width, color) {
            ctx.beginPath();
            ctx.lineWidth = width;
            ctx.lineCap = 'round';
            ctx.strokeStyle = color;
            ctx.moveTo(center, center);
            ctx.lineTo(center + length * Math.cos(angle), center + length * Math.sin(angle));
            ctx.stroke();
        }
        
        /**
         * Main animation loop.
         */
        function animate() {
            drawClock();
            requestAnimationFrame(animate);
        }

        // Start the animation once the image has loaded
        bgImage.onload = () => {
            // Start the main clock animation loop.
            animate();
        };
    </script>
</body>
</html>
